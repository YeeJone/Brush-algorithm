# 快慢指针系列  

⬜️ 未完成  ✅ 已完成    

✅  [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)  
✅  [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)  
⬜️  [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)  
⬜️  [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)  

  
## 141-环形链表  
实现代码：
```js  
var hasCycle = function(head) {
    if (!head || !head.next) return false
    let fast = head.next, slow =head;
    while (!!fast) {
        if(!fast.next) return false
        fast = fast.next.next
        slow = slow.next
        if (slow === fast) {
            return true
        }
    }

    return false
};
```  
要点总结：
+ 存在环的链表一定要考虑使用快慢指针，**快的总会与慢的相遇**，快慢的体现就是：每次循环，快指针走两个节点，慢指针只移动一个节点；
+ 为什么「快指针」要等于 head.next?
  首先需要明确的一点是，上面的代码 first = head 也是可以的。但如果快指针在一开始先走一步，大多数情况下快慢指针相遇的时间会更快。那为什么不是一开始先走两步呢？因为当有两个节点的时候就可以形成一个环，我们使用的 while 循环，条件现行，所以当只有两个节点且成环时，就会直接不进循环，return false，导致结果错误。  
+ 注意一些边界情况，例如链表长度为 0 的情况；  

## 142. 环形链表 II  
实现代码：
```js  
var detectCycle = function(head) {
    if(!head || !head.next) return null
    let fast = head, slow = head

    while (fast) {
        if(!fast.next) return null
        fast = fast.next.next
        slow = slow.next
        if (fast === slow) {
            let target = head
            while (target !== slow) {
                target = target.next
                slow = slow.next
            }
            return target
        }
    }

    return null
};
```   
要点总结：  
这个问题如果用哈希表来实现，可以说非常简单，因为只要一直循环存储遍历过的节点，如果发现表中已经存在的节点，直接返回该节点即可。但这样实现的空间复杂度是 O(N),并非最优。  
对于环形链表，使用快慢指针在空间复杂度上肯定是最优的，因为只有 O(1)。如果使用快慢指针，就需要找到一个对应关系：  
> 如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与 fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nc。
<img src='../imgs/有环链表[1].png' />  
根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有这个等式：  **a+(n+1)b+nc=2(a+b)**    
  
在上图中我们可以发现，只要我们知道 a 的大小，就能确定入环的节点，那么我们将上面的等式转换一下，可得：**a=c+(n−1)(b+c)**  
从这个等式中可以发现：**slow 指针从相遇点走 a 的距离，刚好等于入环点**。基于此：
> 当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。    
  
故可得上面的代码，此解法空间复杂度为 O(1),时间复杂度为 O(N).
